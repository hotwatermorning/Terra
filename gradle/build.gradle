def ensure_property(def obj, String keyname, List candidates, Integer default_value_index = 0)
{
  if(!obj.hasProperty(keyname)) {
    obj.metaClass.setProperty(keyname, candidates[default_value_index])
  }

  assert(candidates.contains(obj.getProperty(keyname)))
}

// Property about build configuration
ensure_property(project, "config", ["Debug", "Release"])
// Property about ccache.
// (note: ccache is not used if not installed even if this property is true.)
ensure_property(project, "use_ccache", ["true", "false"])

def isWindows() {
  return System.properties['os.name'].toLowerCase().startsWith("windows")
}

ext {
  build_dir_name = "build_${project.config.toLowerCase()}"
  has_ccache = (project.use_ccache == "true" ? "which ccache".execute().waitFor() == 0 : false)
  ccache_path = (has_ccache ? "which ccache".execute().text.trim() : "")
  cmake_ccache_config = (has_ccache
                         ? "-DCMAKE_C_COMPILER_LAUNCHER=\"${ccache_path}\" -DCMAKE_CXX_COMPILER_LAUNCHER=\"${ccache_path}\""
                         : "")
  ccache_envvars = [CC: "${ccache_path} clang", CXX: "${ccache_path} clang++"]
}

// println "has ccache: ${has_ccache}"
// println "ccache path: ${ccache_path}"
// println "cmake ccache config: ${cmake_ccache_config}"

// 渡された文字列を空白で区切って、単語のリストとして返す。
// ただし、引用符(`'` or `"`)で囲まれた範囲は空白で区切らずに一つの単語とみなす。
// 引用符で囲まれた範囲内であっても、`\"`のようにエスケープされているものや、
// 引用符の種類が異なるものは引用符の終わりとはみなさない。
// ex) tokenize(/abc def "ghi \"jkl ' mno" pqr/) => [abc, def, ghi "jkl ' mno, pqr]
def tokenize(String data)
{
  def separator_char = ' '
  def escape_char = '\\'
  def quote_chars = ['\'', '"']

  String token = ""
  def output = []
  def in_esc = false
  def found_quote = ""
  def in_string = { found_quote != "" }

  data.each {
    if(in_string()) {
      if(in_esc) {
        in_esc = false
      } else if(it == escape_char) {
        in_esc = true
        return
      } else if(it == found_quote) {
        found_quote = ""
        return
      }
    } else {
      if(quote_chars.contains(it)) {
        found_quote = it
        return
      } else if(it == separator_char) {
        if(token != "") {
          output << token
          token = ""
        }
        return
      }
    }

    token += it
  }

  assert(in_esc == false)
  assert(in_string() == false)

  if(token != "") { output << token }
  return output
}

//! @param params is executable and the parameters which are passed to the executable.
//! @param working_dir is the working directory for the executable.
//! @param env_vars is environment variables as a list of key:value pair. this parameter may be nil.
def execute_with_exit_code(def params, String working_dir = ".", def env_vars = [:])
{
  if(isWindows()) {
    params = "cmd /c chcp 65001 & " + params.toString()
    def java_opts = (env_vars.get("JAVA_OPTS", "") + " -Dfile.encoding=UTF-8")
    env_vars << ["JAVA_OPTS": java_opts.toString()]
  }

  def tmp = tokenize(params)
  println "${tmp} @ '${working_dir}' (${env_vars})"

  def pb = new ProcessBuilder(tokenize(params)).redirectErrorStream(true)
  pb.directory(file(working_dir).getAbsoluteFile())

  if(env_vars) {
    def pb_env = pb.environment()
    env_vars.each { key, value -> pb_env.put(key, value) }
  }

  def process = pb.start()
  process.inputStream.eachLine { println it }
  return process.waitFor()
}

//! similar to execute_with_exit_code but this function fails if the target command ends with exit code of non zero.
def execute(def params, String working_dir = ".", def env_vars = [:])
{
  def exit_code = execute_with_exit_code(params, working_dir, env_vars)
  assert (exit_code == 0)
}

task update_submodules {
  doLast {
    execute("git submodule update --init --recursive", "..")
  }
}

task build_protobuf {
  doLast {
    def build_dir = file("../ext/protobuf/${build_dir_name}").getAbsolutePath()

    execute("mkdir -p ${build_dir}")
    execute("./autogen.sh", "../ext/protobuf")
    execute("../configure --disable-shared --prefix=${build_dir}/install",
            build_dir,
            ccache_envvars
            )
    execute("make", build_dir)
    execute("make install", build_dir)
  }
}
build_protobuf.mustRunAfter update_submodules


task build_portaudio {
  doLast {
    def portaudio_build_dir = file("../ext/portaudio/${build_dir_name}").getAbsolutePath()
    execute("mkdir -p ${portaudio_build_dir}")
    execute("cmake -DPA_BUILD_STATIC=ON -DCMAKE_BUILD_TYPE=${project.config} ${cmake_ccache_config} ..", portaudio_build_dir)
    execute("make -j", portaudio_build_dir)
  }
}
build_portaudio.mustRunAfter update_submodules


task build_vst3sdk {
  doLast {
    // vst3sdk
    def vst3sdk_build_dir = file("../ext/vst3sdk/${build_dir_name}").getAbsolutePath()
    execute("mkdir -p ${vst3sdk_build_dir}")
    execute("cmake -DCMAKE_BUILD_TYPE=${project.config} ${cmake_ccache_config} ..", vst3sdk_build_dir)
    execute("make -j", vst3sdk_build_dir)
  }
}
build_vst3sdk.mustRunAfter update_submodules

task build_wxwidgets {
  doLast {
    // wxwidgets
    def wx_build_dir = file("../ext/wxWidgets/${build_dir_name}").getAbsolutePath()

    def debug_flags = ""
    if(project.config == "Debug") {
      debug_flags = "--enable-debug --enable-debug-info --enable-debug-gdb"
    }

    execute("./autogen.sh", "../ext/wxWidgets")
    execute("mkdir -p ${wx_build_dir}")
    execute('../configure CXXFLAGS="-stdlib=libc++ -DHAVE_TYPE_TRAITS" OBJCXXFLAGS="-stdlib=libc++" ' +
            'CPPFLAGS="-stdlib=libc++" LDFLAGS="-stdlib=libc++" ' +
            '--with-macosx-version-min=10.7 --with-cocoa ' +
            '--with-libjpeg=builtin --with-libpng=builtin --with-regex=builtin --with-libtiff=builtin ' +
            '--with-zlib=builtin --with-expat=builtin ' +
            '--enable-stl --enable-std_containers --enable-std_iostreams --enable-std_string ' +
            "--disable-shared --enable-unicode ${debug_flags} --with-cxx=14 --prefix=${wx_build_dir}/install",
            wx_build_dir,
            ccache_envvars
            )
    execute("make", wx_build_dir)
    execute("make install", wx_build_dir)
  }
}
build_wxwidgets.mustRunAfter update_submodules

task build_fmtlib {
  doLast {
    def build_dir = file("../ext/fmt/${build_dir_name}").getAbsolutePath()
    execute("mkdir -p ${build_dir}")
    execute("cmake -DCMAKE_BUILD_TYPE=${project.config} ${cmake_ccache_config} ..", build_dir)
    execute("make -j", build_dir)
  }
}
build_fmtlib.mustRunAfter update_submodules

task compile_schemas {
  doLast {
    execute("mkdir -p schema/cpp", "..")
    file("../schema").eachFileMatch(~/.*\.proto$/) {
      execute("./ext/protobuf/${build_dir_name}/install/bin/protoc -Ischema --cpp_out=schema/cpp ${it.getName()}", "..")
    }
  }
}
compile_schemas.mustRunAfter build_protobuf

task build_submodules {
  dependsOn { [build_protobuf, compile_schemas, build_portaudio, build_vst3sdk, build_wxwidgets, build_fmtlib] }
}

task prepare_app {
  doLast {
    def build_dir = file("../${build_dir_name}").getAbsolutePath()
    execute("mkdir -p ${build_dir}")
    execute("cmake -GXcode -DCMAKE_BUILD_TYPE=${project.config} ${cmake_ccache_config} ..", build_dir)
  }
}
prepare_app.mustRunAfter build_submodules
prepare_app.mustRunAfter compile_schemas

task build_app {
  doLast {
    def build_dir = file("../${build_dir_name}").getAbsolutePath()
    execute("xcodebuild -configuration ${project.config}", build_dir)
  }
}
build_app.mustRunAfter prepare_app

//! 指定したディレクトリの直下にあるディレクトリのうち、
//! 現在のビルド構成によって決まるディレクトリ名と同じディレクトリがあれば、それを削除する。
def delete_build_dir(def target_dir) {
  file(target_dir).eachDir() {
    if(it.getName() == build_dir_name) {
      println "dir path to delete: ${it.getAbsolutePath()}"
      it.deleteDir()
    }
  }
}

task clean_submodules {
  doLast {
    file("../ext").eachDir {
      delete_build_dir(it)
    }
  }
}

task clean_app {
  doLast {
    delete_build_dir("..")
  }
}

task clean {
  dependsOn { [clean_submodules, clean_app] }
}

task build_all {
  dependsOn { [update_submodules, build_submodules, prepare_app, build_app] }
}

