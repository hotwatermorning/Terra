import groovy.json.*
import groovy.transform.Field
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

@Field def slurper = new JsonSlurper()

def ensure_property(def obj, String keyname, List candidates, Integer default_value_index = 0)
{
  if(!obj.hasProperty(keyname)) {
    obj.metaClass.setProperty(keyname, candidates[default_value_index])
  }

  assert(candidates.contains(obj.getProperty(keyname)))
}

// Property about build configuration
ensure_property(project, "config", ["Debug", "Release"])
// Property about ccache.
// (note: ccache is not used if not installed even if this property is true.)
ensure_property(project, "use_ccache", ["true", "false"])
// build libraries even if cache archives are available.
ensure_property(project, "renew_cache", ["false", "true"])

ext {
  getenv = { String key -> return java.lang.System.getenv()[key] }
  isWindows = { return System.properties['os.name'].toLowerCase().startsWith("windows") }
  build_dir_name = "build_${project.config.toLowerCase()}"
  has_ccache = (project.use_ccache == "true" ? "which ccache".execute().waitFor() == 0 : false)
  ccache_path = (has_ccache ? "which ccache".execute().text.trim() : "")
  ccache_envvars = (has_ccache ? [CC: "${ccache_path} clang", CXX: "${ccache_path} clang++"] : [:])
  should_renew_cache = (project.renew_cache == "true")
}

// 渡された文字列を空白で区切って、単語のリストとして返す。
// ただし、引用符(`'` or `"`)で囲まれた範囲は空白で区切らずに、ひと続きの文字列とみなす
// 引用符で囲まれた範囲内であっても、`\"`のようにエスケープされているものや、
// 引用符の種類が異なるものは引用符の終わりとはみなさない。
// ex) tokenize(/abc def "ghi \"jkl ' mno" pqr/) => [abc, def, "ghi \"jkl ' mno", pqr]
// @return [
//    tokens: <tokenized string list if succeeded, [] otherwise>,
//    error: <error msg if something failed, "" otherwise.>
// ]
def tokenize_with_error(String src)
{
  logger.info("start tokenize: ${src}")

  def separator_char = ' '
  def escape_char = '\\'
  def quote_chars = [/'/, /"/]

  String token = ""
  def output = []
  def is_escaped = false
  def found_quote = ""
  def quoted = { found_quote != "" }

  src.each { it ->
    logger.debug("it: ${it}")

    if(quoted()) {
      if(is_escaped) {
        is_escaped = false
        logger.debug("\t--1")
      } else if(it == escape_char) {
        is_escaped = true
        logger.debug("\t--2")
      } else if(it == found_quote) {
        found_quote = ""
        logger.debug("\t--3")
        return
      }
    } else {
      if(quote_chars.contains(it)) {
        found_quote = it
        logger.debug("\t--4")
        return
      } else if(it == separator_char) {
        if(token != "") {
          logger.debug("\t--5")
          output << token
          token = ""
        }
        return
      }
    }

    token += it
  }

  if(quoted()) {
    return [ tokens: [], error: "quotation is not closed." ]
  }

  if(token != "") { output << token }
  return [ tokens: output, error: "" ]
}

def tokenize(String str)
{
  def result = tokenize_with_error(str)
  assert(result.error == "")
  return result.tokens
}

task test_tokenize {
  def is_failed = false
  def fail = { String msg ->
    logging.error(msg)
    is_failed = true
  }
  def test = { String str, List expected ->
    def result = tokenize_with_error(str)
    if(result.tokens != expected) {
      fail("given:[${str}], expected:${expected}, but:" + result.tokens)
    }
  }
  doLast {
    test("", [])
    test("abc", ["abc"])
    test(/"abc"/, [/"abc"/])
    test('abc def', ["abc", "def"])
    test("abc'def", [])            // error: /'/ is not closed.
    test('abc"def', [])            // error: /"/ is not closed.
    test($/abc"def\"/$, [])        // error: /"/ is not closed because escaped.
    test("abc'def'", ["abc'def'"])
    test("abc 'def ghi'", ["abc", "'def ghi'"])
    test("abc'def ghi'", ["abc'def ghi'"])
    test($/abc 'def" ghi'/$, ["abc", $/'def" ghi'/$]) // /"/ can be placed and no need to be closed in /'/ pair
    test($/abc "def\" 'ghi jkl'"/$, ["abc", $/"def\" 'ghi jkl'"/$])

    if(is_failed) { assert false, "[FAILED]" } else { println "[PASS]" }
  }
}
test_tokenize.description = """test tokenize() function"""

class ExecutionResult
{
  def ExecutionResult(int exit_value, String text, String error_text)
  {
    this.exit_value = exit_value
    this.text = text
    this.error_text = error_text
  }

  int exitValue() { return exit_value }
  boolean succeeded() { return exit_value == 0 }
  boolean failed() { return exit_value != 0 }

  String getText() { return text }
  String getErrorText() { return error_text }

  int exit_value
  String text
  String error_text
}

//! execute specified command and wait for finish the execution.
//! @param command is a string consists of executable command and its parameters.
//! @param working_dir is the working directory for the executable.
//! @param env_vars is environment variables as a list of key:value pair. this parameter may be nil.
@Field def execute_may_fail = { String command, def working_dir = ".", Map env_vars = [:] ->
  if(isWindows()) {
    command = "cmd /c chcp 65001 & " + command.toString()
    def java_opts = (env_vars.get("JAVA_OPTS", "") + " -Dfile.encoding=UTF-8")
    env_vars << ["JAVA_OPTS": java_opts.toString()]
  }

  def tmp = tokenize(command)
  println "${tmp} @ '${working_dir}' (${env_vars})"

  def pb = new ProcessBuilder(tokenize(command))
  pb.directory(file(working_dir).getAbsoluteFile())

  if(env_vars) {
    def pb_env = pb.environment()
    env_vars.each { key, value -> pb_env.put(key, value) }
  }

  def process = pb.start()
  String text = ""
  String error_text = ""

  def service = Executors.newCachedThreadPool()

  service.execute {
    process.in.eachLine { line ->
      text += line + "\n"
      System.out.&println line
    }
  }

  service.execute {
    process.err.eachLine { line ->
      error_text += line + "\n"
      System.err.&println line
    }
  }

  process.waitFor()

  service.shutdown()
  service.awaitTermination(1, TimeUnit.MINUTES)

  return new ExecutionResult(process.exitValue(), text, error_text)
}

//! similar to execute_may_fail but this function fails if the command finished with an exit value of non zero.
@Field def execute = { String params, def working_dir = ".", Map env_vars = [:] ->
  def result = execute_may_fail(params, working_dir, env_vars)
  assert (result.exitValue() == 0), "undesirable exit value ${result.exitValue()}"
  return result
}

task update_submodules {
  doLast {
    execute("git submodule update --init --recursive", "..")
  }
}

// 指定したディレクトリが存在しなければ作成し、成功か失敗かをbooleanで返す
// 存在する場合は何もせずにtrueを返す
@Field def mkdirs_if_needed = { def path ->
  def f = file(path)
  if(f.exists()) { return true }

  return f.mkdirs()
}

@Field def createCacheParam = { File cache_dir, String archive_name, String build_config, String hash ->
  def getOsName = { return isWindows() ? "win" : "mac" }
  return [
    getOsName: getOsName,
    cache_dir: cache_dir,
    archive_name: archive_name,
    build_config: build_config,
    hash: hash,
    getArchiveFileName: {
      def name = "${archive_name}_${getOsName()}_${build_config}_${hash}.tar.gz"
      assert(name.contains(" ") == false)
      return name
    }
  ]
}

// interface CacheStrategy
// {
//   boolean fetch(def param)
//   boolean store(def param)
// }

@Field def createNullCacheStrategy = {
  return [
    fetch: { def param -> return false },
    store: { def param -> return false },
  ]
}

@Field def createAzureCacheStrategy = {
  def getAzureStorageAccount = {
    return getenv("AZURE_STORAGE_ACCOUNT").toString()
  }

  def getAzureStorageKey = {
    return getenv("AZURE_STORAGE_KEY").toString()
  }

  def getAzureStorageContainerName = {
    return getenv("AZURE_STORAGE_CONTAINER_NAME").toString()
  }

  def getBlobApiParams = {
    return  " --container-name ${getAzureStorageContainerName()} "
    +       " --storage-account ${getAzureStorageAccount()} "
    +       " --storage-key ${getAzureStorageKey()} "
  }

  def isCached = { def param ->
    def result = execute_may_fail(
      " az storage blob exists ${getBlobApiParams()} "
      + " --name ${param.getArchiveFileName()} "
      )

    if(result.failed()) {
      logger.warn("failed to check the blob existence")
      return false
    }

    def blob_exists_result = slurper.parseText(result.text)
    assert blob_exists_result

    if(blob_exists_result.exists == false) {
      return false
    }
  }

  if(execute_may_fail("bash -c \"which az\"").failed()) { return null }
  if(getAzureStorageAccount()?.trim() == false
     || getAzureStorageKey()?.trim() == false
     || getAzureStorageContainerName()?.trim() == false
   )
   { return null }

  return [
    fetch: { def param ->
      if(isCached(param) == false) {
        return false
      }

      if(mkdirs_if_needed(param.cache_dir) == false) {
        assert false, "failed to create ${param.cache_dir}"
      }

      def result = execute_may_fail(
        " az storage blob download ${getBlobApiParams()} "
        + " --name ${param.getArchiveFileName()} "
        + " --file ${param.getArchiveFileName()} "
        , param.cache_dir)

      if(result.failed()) {
        logger.warn("failed to download the blob")
        return false
      }

      // extract archive
      result = execute_may_fail(
        "tar xvf ${param.getArchiveFileName()}"
        , param.cache_dir)

      if(result.failed()) {
        logger.warn("failed extract ${param.getArchiveFileName()}")
        return false
      }

      // remove downloaded archive
      execute("rm ${param.getArchiveFileName()}", param.cache_dir)

      return true
    },
    store: { def param ->
      assert(file(param.cache_dir).exists())

      execute(
        "tar -jcvhf ${param.getArchiveFileName()} ./"
        , param.cache_dir)

      def result = execute_may_fail(
        " az storage blob upload "
        + " ${getBlobApiParams()} "
        + " --name ${param.getArchiveFileName()} "
        + " --file ${param.getArchiveFileName()} "
        , param.cache_dir)

      execute("rm ${param.getArchiveFileName()}", param.cache_dir)

      if(result.failed()) {
        logger.warn("failed to upload cache")
        return false
      }

      return true
    },
    isCached: isCached,
  ]
}

@Field def get_hash = { String submodule_name ->
  def result = execute("git rev-parse HEAD", file("../ext/${submodule_name}"))
  return result.text.trim()
}

@Field def get_cache_strategy = {
  def st = createAzureCacheStrategy()
  if(st) {
    println "Use AzureCacheStrategy"
  }

  if(st == null) {
    st = createNullCacheStrategy()
    println "Use NullCacheStrategy"
  }

  return st
}

// 指定したディレクトリのキャッシュが有効なときはそれを使用し、
// キャッシュがないときはビルドを行う
@Field def build_if_needed = { String archive_name, File cache_dir, String hash, Closure do_build ->
  def cache = get_cache_strategy()

  def param = createCacheParam(cache_dir, archive_name, project.config, hash)

  // fetchしたデータの正当性は確認しない
  // （正当性を確認して、内容が不十分なときはdo_buildでビルドし直すような設計も考えられるが、
  // do_buildの実装側が面倒になるので、そこまではしない）
  if(should_renew_cache == false && cache.fetch(param)) {
    return
  }

  do_build()
  def result = cache.store(param)
  if(result == false) {
    logger.warn("Failed to store cache")
  }
}

task build_protobuf {
  doLast {
    println "Build Protocol Buffer"
    def build_dir = file("../ext/protobuf/${build_dir_name}").getAbsolutePath()

    build_if_needed(
      "protobuf",
      file("${build_dir}/install"),
      get_hash("protobuf"),
      {
        execute("mkdir -p ${build_dir}")
        execute("./autogen.sh", "${build_dir}/..")
        execute("../configure --disable-shared --prefix=${build_dir}/install",
                build_dir,
                ccache_envvars
                )
        execute("make", build_dir)
        execute("make install", build_dir)
      })
  }
}
build_protobuf.mustRunAfter update_submodules

task build_rtmidi {
  doLast {
    println "Build RtMidi"
    def build_dir = file("../ext/rtmidi/${build_dir_name}").getAbsolutePath()

    build_if_needed(
      "rtmidi",
      file("${build_dir}/install"),
      get_hash("rtmidi"),
      {
        execute("mkdir -p ${build_dir}")
        execute("cmake -DCMAKE_INSTALL_PREFIX=${build_dir}/install -DBUILD_SHARED_LIBS=OFF -DBUILD_TESTING=OFF -DCMAKE_BUILD_TYPE=${project.config} ..", build_dir, ccache_envvars)
        execute("make -j", build_dir)
        execute("make install", build_dir)
      })
  }
}
build_rtmidi.mustRunAfter update_submodules

task build_portaudio {
  doLast {
    println "Build PortAudio"
    def build_dir = file("../ext/portaudio/${build_dir_name}").getAbsolutePath()

    build_if_needed(
      "portaudio",
      file("${build_dir}/install"),
      get_hash("portaudio"),
      {
        execute("mkdir -p ${build_dir}")
        execute("cmake -DCMAKE_INSTALL_PREFIX=${build_dir}/install -DPA_BUILD_STATIC=ON -DCMAKE_BUILD_TYPE=${project.config} ..", build_dir, ccache_envvars)
        execute("make -j", build_dir)
        execute("make install", build_dir)
      })
  }
}
build_portaudio.mustRunAfter update_submodules


task build_vst3sdk {
  doLast {
    println "Build VST3 SDK"
    def build_dir = file("../ext/vst3sdk/${build_dir_name}").getAbsolutePath()

    build_if_needed(
      "vst3sdk",
      file(build_dir),
      get_hash("vst3sdk"),
      {
        execute("mkdir -p ${build_dir}")
        // VST3SDKは、makeのinstallターゲットを用意しない
        execute(
          " cmake -DCMAKE_BUILD_TYPE=${project.config} "
          + " -DSMTG_ADD_VST3_PLUGINS_SAMPLES=OFF "
          + " -DSMTG_ADD_VST3_HOSTING_SAMPLES=OFF "
          + " -DSMTG_ADD_VSTGUI=OFF "
          + ".."
          , build_dir, ccache_envvars)
        execute("make -j", build_dir)
      })
  }
}
build_vst3sdk.mustRunAfter update_submodules

task build_wxwidgets {
  doLast {
    println "Build wxWidgets"
    def build_dir = file("../ext/wxWidgets/${build_dir_name}").getAbsolutePath()

    build_if_needed(
      "wxwidgets",
      file("${build_dir}/install"),
      get_hash("wxWidgets"),
      {
        def debug_flags = ""
        if(project.config == "Debug") {
          debug_flags = "--enable-debug --enable-debug-info --enable-debug-gdb"
        }

        execute("./autogen.sh", "../ext/wxWidgets")
        execute("mkdir -p ${build_dir}")
        execute('../configure CXXFLAGS="-stdlib=libc++ -DHAVE_TYPE_TRAITS" OBJCXXFLAGS="-stdlib=libc++" ' +
                'CPPFLAGS="-stdlib=libc++" LDFLAGS="-stdlib=libc++" ' +
                '--with-macosx-version-min=10.7 --with-cocoa ' +
                '--with-libjpeg=builtin --with-libpng=builtin --with-regex=builtin --with-libtiff=builtin ' +
                '--with-zlib=builtin --with-expat=builtin ' +
                '--enable-stl --enable-std_containers --enable-std_iostreams --enable-std_string ' +
                "--disable-shared --enable-unicode ${debug_flags} --with-cxx=14 --prefix=${build_dir}/install",
                build_dir,
                ccache_envvars
                )
        execute("make", build_dir)
        execute("make install", build_dir)
      })
  }
}
build_wxwidgets.mustRunAfter update_submodules

task build_fmtlib {
  doLast {
    println "Build fmtlib"
    def build_dir = file("../ext/fmt/${build_dir_name}").getAbsolutePath()

    build_if_needed(
      "fmtlib",
      file("${build_dir}/install"),
      get_hash("fmt"),
      {
        execute("mkdir -p ${build_dir}")
        execute("cmake -DCMAKE_INSTALL_PREFIX=${build_dir}/install -DCMAKE_BUILD_TYPE=${project.config} ..", build_dir, ccache_envvars)
        execute("make -j", build_dir)
        execute("make install", build_dir)
      })
  }
}
build_fmtlib.mustRunAfter update_submodules

task compile_schemas {
  doLast {
    def protoc = file("../ext/protobuf/${build_dir_name}/install/bin/protoc").getAbsolutePath()
    assert(file(protoc).exists())

    execute("mkdir -p schema/cpp", "..")
    file("../schema").eachFileMatch(~/.*\.proto$/) {
      execute("${protoc} -Ischema --cpp_out=schema/cpp ${it.getName()}", "..")
    }
  }
}
compile_schemas.mustRunAfter build_protobuf

task build_submodules {
  dependsOn { [build_protobuf, compile_schemas, build_rtmidi, build_portaudio, build_vst3sdk, build_wxwidgets, build_fmtlib] }
}

task prepare_app {
  doLast {
    def build_dir = file("../${build_dir_name}").getAbsolutePath()
    execute("mkdir -p ${build_dir}")
    execute("cmake -GXcode -DCMAKE_BUILD_TYPE=${project.config} ..", build_dir)
  }
}
prepare_app.mustRunAfter build_submodules
prepare_app.mustRunAfter compile_schemas

task build_app {
  doLast {
    def build_dir = file("../${build_dir_name}").getAbsolutePath()
    execute("xcodebuild -configuration ${project.config}", build_dir)
  }
}
build_app.mustRunAfter prepare_app

//! 指定したディレクトリの直下にあるディレクトリのうち、
//! 現在のビルド構成によって決まるディレクトリ名と同じディレクトリがあれば、それを削除する。
def delete_build_dir(def target_dir) {
  file(target_dir).eachDir() {
    if(it.getName() == build_dir_name) {
      println "dir path to delete: ${it.getAbsolutePath()}"
      it.deleteDir()
    }
  }
}

task clean_submodules {
  doLast {
    file("../ext").eachDir {
      delete_build_dir(it)
    }
  }
}

task clean_app {
  doLast {
    delete_build_dir("..")
  }
}

task clean_all {
  dependsOn { [clean_submodules, clean_app] }
}

task build_all {
  dependsOn { [update_submodules, build_submodules, prepare_app, build_app] }
}

